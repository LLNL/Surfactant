diff --git a/surfactant/cmd/generate.py b/surfactant/cmd/generate.py
index 064c368..872dbc8 100644
--- a/surfactant/cmd/generate.py
+++ b/surfactant/cmd/generate.py
@@ -403,6 +403,22 @@ def sbom(
                         raise RuntimeError(f"Unable to process: {filepath}") from e
                     entries.append(sw_parent)
                     entries.extend(sw_children if sw_children else [])
+                    # ------------------------------------------------------------------------
+                    # Inject symlink paths into each Software entry so SBOM helper handles them
+                    # ------------------------------------------------------------------------
+                    for sw in entries:
+                        # Filename symlinks
+                        for link in filename_symlinks.get(sw.sha256, []):
+                            logger.debug(
+                                f"Injecting filename symlink '{link}' for SHA {sw.sha256}"
+                            )
+                            sw.fileName.append(link)
+                        # Install-path symlinks
+                        for link in file_symlinks.get(sw.sha256, []):
+                            logger.debug(
+                                f"Injecting install-path symlink '{link}' for SHA {sw.sha256}"
+                            )
+                            sw.installPath.append(link)
                     new_sbom.add_software_entries(entries, parent_entry=parent_entry)
                     # epath was a file, no need to walk the directory tree
                     continue
@@ -519,6 +535,22 @@ def sbom(
 
                                 entries.append(sw_parent)
                                 entries.extend(sw_children if sw_children else [])
+                    # ------------------------------------------------------------------------
+                    # Inject symlink paths into each Software entry so SBOM helper handles them
+                    # ------------------------------------------------------------------------
+                    for sw in entries:
+                        # Filename symlinks
+                        for link in filename_symlinks.get(sw.sha256, []):
+                            logger.debug(
+                                f"Injecting filename symlink '{link}' for SHA {sw.sha256}"
+                            )
+                            sw.fileName.append(link)
+                        # Install-path symlinks
+                        for link in file_symlinks.get(sw.sha256, []):
+                            logger.debug(
+                                f"Injecting install-path symlink '{link}' for SHA {sw.sha256}"
+                            )
+                            sw.installPath.append(link)
                     new_sbom.add_software_entries(entries, parent_entry=parent_entry)
 
         # Add symlinks to install paths and file names
@@ -589,7 +621,6 @@ def sbom(
     # TODO should contents from different containers go in different SBOM files, so new portions can be added bit-by-bit with a final merge?
     output_writer.write_sbom(new_sbom, sbom_outfile)
 
-
 def resolve_link(
     path: str, cur_dir: str, extract_dir: str, install_prefix: Optional[str] = None
 ) -> Union[str, None]:
@@ -626,4 +657,4 @@ def resolve_link(
     if not os.path.exists(current_path):
         logger.warning(f"Resolved symlink {path} to a path that doesn't exist {current_path}")
         return None
-    return os.path.normpath(current_path)
+    return os.path.normpath(current_path)
\ No newline at end of file
diff --git a/surfactant/relationships/dotnet_relationship.py b/surfactant/relationships/dotnet_relationship.py
index 4082732..08bf5b5 100644
--- a/surfactant/relationships/dotnet_relationship.py
+++ b/surfactant/relationships/dotnet_relationship.py
@@ -9,8 +9,6 @@ from typing import List, Optional
 import surfactant.plugin
 from surfactant.sbomtypes import SBOM, Relationship, Software
 
-from ._internal.windows_utils import find_installed_software
-
 
 def has_required_fields(metadata) -> bool:
     # dotnetAssemblyRef must present, otherwise we have no info on .NET imports
@@ -26,9 +24,11 @@ def establish_relationships(
 
     relationships: List[Relationship] = []
     dependent_uuid = software.UUID
+
     dnName = None
     dnCulture = None
     dnVersion = None
+
     if "dotnetAssembly" in metadata:
         dnAssembly = metadata["dotnetAssembly"]
         if "Name" in dnAssembly:
@@ -38,16 +38,11 @@ def establish_relationships(
         if "Version" in dnAssembly:
             dnVersion = dnAssembly["Version"]
 
-    # get additional probing paths if they exist
+    # Extract probing and dependent assembly info from appConfig if present
     dnProbingPaths = None
     dnDependentAssemblies = None
-
-    windowsAppConfig = None
-    windowsManifest = None
-    if "appConfigFile" in metadata:
-        windowsAppConfig = metadata["appConfigFile"]
-    if "manifestFile" in metadata:
-        windowsManifest = metadata["manifestFile"]
+    windowsAppConfig = metadata.get("appConfigFile")
+    windowsManifest = metadata.get("manifestFile")  # Currently unused
 
     if windowsAppConfig:
         if "runtime" in windowsAppConfig:
@@ -80,28 +75,39 @@ def establish_relationships(
     # 4. Run default unmanaged library probing logic by parsing *.deps.json probing properties
     #    - a. If the json file isn't present, assume the calling assembly's directory contains the library
     #    - b. https://learn.microsoft.com/en-us/dotnet/core/dependency-loading/default-probing#unmanaged-native-library-probing
+    
+    
+    # Handle unmanaged dependencies declared via [DllImport] or P/Invoke
     if "dotnetImplMap" in metadata:
         for asmRef in metadata["dotnetImplMap"]:
             if "Name" not in asmRef:
                 continue
             refName = asmRef["Name"]
 
-            # Check absolute path against entries in software
+            # Absolute path: resolve directly using fs_tree
             if is_absolute_path(refName):
-                ref_abspath = pathlib.PureWindowsPath(refName)
-                for e in sbom.software:
-                    if e.installPath is None:
-                        continue
-                    if isinstance(e.installPath, Iterable):
-                        for ifile in e.installPath:
-                            if ref_abspath == pathlib.PureWindowsPath(ifile):
-                                relationships.append(Relationship(dependent_uuid, e.UUID, "Uses"))
+                ref_abspath = pathlib.PureWindowsPath(refName).as_posix()
+                match = sbom.get_software_by_path(ref_abspath)
+
+                if match:
+                    relationships.append(Relationship(dependent_uuid, match.UUID, "Uses"))
                 continue
 
+                # for e in sbom.software:
+                #     if e.installPath is None:
+                #         continue
+                #     if isinstance(e.installPath, Iterable):
+                #         for ifile in e.installPath:
+                #             if ref_abspath == pathlib.PureWindowsPath(ifile):
+                #                 relationships.append(Relationship(dependent_uuid, e.UUID, "Uses"))
+                # continue
+
+            # Construct candidate paths relative to installPath
             probedirs = []
             if isinstance(software.installPath, Iterable):
                 for ipath in software.installPath:
                     probedirs.append(pathlib.PureWindowsPath(ipath).parent.as_posix())
+
             # Construct a list of combinations specified in (2.a)
             # Refer to Issue #80 - Need to verify that this conforms with cross-platform behavior
             combinations = [refName]
@@ -116,11 +122,19 @@ def establish_relationships(
                     f"lib{refName}",
                 ]
             )
-            # On Linux, if the libname ends with .so or has .so. then version variations are tried
-            # Refer to Issue #79 - Need regex matching for version variations
-            for e in find_installed_software(sbom, probedirs, combinations):
-                dependency_uuid = e.UUID
-                relationships.append(Relationship(dependent_uuid, dependency_uuid, "Uses"))
+
+            for directory in probedirs:
+                for candidate in combinations:
+                    path = pathlib.PurePosixPath(directory, candidate).as_posix()
+                    match = sbom.get_software_by_path(path)
+                    if match:
+                        relationships.append(Relationship(dependent_uuid, match.UUID, "Uses"))
+
+            # # On Linux, if the libname ends with .so or has .so. then version variations are tried
+            # # Refer to Issue #79 - Need regex matching for version variations
+            # for e in find_installed_software(sbom, probedirs, combinations):
+            #     dependency_uuid = e.UUID
+            #     relationships.append(Relationship(dependent_uuid, dependency_uuid, "Uses"))
 
     # https://learn.microsoft.com/en-us/dotnet/framework/deployment/how-the-runtime-locates-assemblies
     # 1. Determine correct assembly version using configuration files (binding redirects, code location, etc)
@@ -134,63 +148,60 @@ def establish_relationships(
     #    - the location of the calling assembly may be used as a hint for where to find the referenced assembly
     if "dotnetAssemblyRef" in metadata:
         for asmRef in metadata["dotnetAssemblyRef"]:
-            refName = None
-            refVersion = None
-            refCulture = None
-            if "Name" in asmRef:
-                refName = asmRef["Name"]
-            else:
-                continue  # no name means we have no assembly to search for
-            if "Culture" in asmRef:
-                refCulture = asmRef["Culture"]
-            if "Version" in asmRef:
-                refVersion = asmRef["Version"]
+            refVersion = asmRef.get("Version")
+            refCulture = asmRef.get("Culture")
+            refName = asmRef.get("Name")
+
+            if not refName:
+                continue # no name means we have no assembly to search for
+
 
             # check if codeBase element exists for this assembly in appconfig
-            if dnDependentAssemblies is not None:
+            # Resolve from <codeBase href="..."> entries in app config
+            if dnDependentAssemblies:
                 for depAsm in dnDependentAssemblies:
                     # dependent assembly object contains info on assembly id and binding redirects that with a better internal SBOM
                     # representation could be used to also verify the right assembly is being found
-                    if "codeBase" in depAsm:
-                        if "href" in depAsm["codeBase"]:
-                            codebase_href = depAsm["codeBase"]["href"]
-                            # strong named assembly can be anywhere on intranet or Internet
-                            if (
-                                codebase_href.startswith("http://")
-                                or codebase_href.startswith("https://")
-                                or codebase_href.startswith("file://")
-                            ):
-                                # codebase references a url; interesting for manual analysis/gathering additional files, but not supported by surfactant yet
-                                pass
-                            else:
-                                # most likely a private assembly, so path must be relative to application's directory
-                                if isinstance(software.installPath, Iterable):
-                                    for install_filepath in software.installPath:
-                                        install_basepath = pathlib.PureWindowsPath(
-                                            install_filepath
-                                        ).parent.as_posix()
-                                        cb_filepath = pathlib.PureWindowsPath(
-                                            install_basepath, codebase_href
-                                        )
-                                        cb_file = cb_filepath.name
-                                        cb_path = [cb_filepath.parent.as_posix()]
-                                        for e in find_installed_software(sbom, cb_path, cb_file):
-                                            dependency_uuid = e.UUID
-                                            relationships.append(
-                                                Relationship(
-                                                    dependent_uuid,
-                                                    dependency_uuid,
-                                                    "Uses",
-                                                )
-                                            )
+                    if "codeBase" in depAsm and "href" in depAsm["codeBase"]:
+                        href = depAsm["codeBase"]["href"]
+                        
+                        # strong named assembly can be anywhere on intranet or Internet
+                        # Skip external URLs we cannot resolve locally
+                        if (
+                            href.startswith("http://")
+                            or href.startswith("https://")
+                            or href.startswith("file://")
+                        ):
+                            # codebase references a url; interesting for manual analysis/gathering additional files, but not supported by surfactant yet
+                            continue
+
+                        # most likely a private assembly, so path must be relative to application's directory
+                        if isinstance(software.installPath, Iterable):
+                            for ipath in software.installPath:
+                                base = pathlib.PureWindowsPath(ipath).parent.as_posix()
+                                cb_fullpath = pathlib.PurePosixPath(base, href).as_posix()
+                                match = sbom.get_software_by_path(cb_fullpath)
+                                if match:
+                                    relationships.append(Relationship(dependent_uuid, match.UUID, "Uses"))
 
             # continue on to probing even if codebase element was found, since we can't guarantee the assembly identity required by the codebase element
             # get the list of paths to probe based on locations software is installed, assembly culture, assembly name, and probing paths from appconfig file
-            probedirs = get_dotnet_probedirs(software, refCulture, refName, dnProbingPaths)
-            for e in find_installed_software(sbom, probedirs, refName + ".dll"):
-                dependency_uuid = e.UUID
-                relationships.append(Relationship(dependent_uuid, dependency_uuid, "Uses"))
+
+            # Probe using resolved directories and file name
+            probedirs = get_dotnet_probedirs(
+                software,
+                refCulture,
+                refName,
+                dnProbingPaths,
+            )
+
+            for directory in probedirs:
+                path = pathlib.PurePosixPath(directory, refName + ".dll").as_posix()
+                match = sbom.get_software_by_path(path)
+                if match:
+                    relationships.append(Relationship(dependent_uuid, match.UUID, "Uses"))
                 # logging assemblies not found would be nice but is a lot of noise as it mostly just prints system/core .NET libraries
+                
     return relationships
 
 
@@ -211,7 +222,7 @@ def get_dotnet_probedirs(software: Software, refCulture, refName, dnProbingPaths
                 # [application base] / [assembly name] / [assembly name].dll
                 probedirs.append(pathlib.PureWindowsPath(install_basepath).as_posix())
                 probedirs.append(pathlib.PureWindowsPath(install_basepath, refName).as_posix())
-                if dnProbingPaths is not None:
+                if dnProbingPaths:
                     # add probing private paths
                     for path in dnProbingPaths:
                         # [application base] / [binpath] / [assembly name].dll
@@ -227,7 +238,7 @@ def get_dotnet_probedirs(software: Software, refCulture, refName, dnProbingPaths
                 probedirs.append(
                     pathlib.PureWindowsPath(install_basepath, refName, refCulture).as_posix()
                 )
-                if dnProbingPaths is not None:
+                if dnProbingPaths:
                     # add probing private paths
                     for path in dnProbingPaths:
                         # [application base] / [binpath] / [culture] / [assembly name].dll
diff --git a/surfactant/relationships/elf_relationship.py b/surfactant/relationships/elf_relationship.py
index 5563574..b1b7f84 100644
--- a/surfactant/relationships/elf_relationship.py
+++ b/surfactant/relationships/elf_relationship.py
@@ -5,10 +5,10 @@
 import pathlib
 from collections.abc import Iterable
 from typing import List, Optional
+from loguru import logger
 
 import surfactant.plugin
 from surfactant.sbomtypes import SBOM, Relationship, Software
-
 from ._internal.posix_utils import posix_normpath
 
 
@@ -42,157 +42,277 @@ def has_required_fields(metadata) -> bool:
 def establish_relationships(
     sbom: SBOM, software: Software, metadata
 ) -> Optional[List[Relationship]]:
+    """
+    Establishes 'Uses' relationships between a given software entity and its dynamically
+    linked ELF dependencies, based on resolved filesystem paths and SBOM entries.
+
+    This function emulates the dynamic linker’s behavior:
+    - If a dependency path contains '/', treat it as an absolute or relative path.
+    - Otherwise, resolve it using a search path (RPATH, RUNPATH, and system defaults).
+    - Uses SBOM's fs_tree (preferred), legacy installPath-based fallback,
+      and heuristic matching for symlink-style relationships.
+
+    Parameters:
+        sbom (SBOM): The complete software bill of materials.
+        software (Software): The software object whose dependencies are being resolved.
+        metadata (dict): ELF metadata containing dependency information (e.g. 'elfDependencies').
+
+    Returns:
+        Optional[List[Relationship]]: A list of Relationship objects indicating usage,
+                                      or None if metadata is incomplete.
+    """
     if not has_required_fields(metadata):
         return None
 
     relationships: List[Relationship] = []
     dependent_uuid = software.UUID
     default_search_paths = generate_search_paths(software, metadata)
+    logger.debug(f"Default search paths: {[p.as_posix() for p in default_search_paths]}")
+
     for dep in metadata["elfDependencies"]:
-        # if dependency has a slash, it is interpreted as a pathname to shared object to load
-        # construct fname and full file path(s) to search for; paths must be a list if the dependency is given as a relative path
+        fpaths = []
+        dep_path = posix_normpath(dep)
+        fname = dep_path.name  # e.g., 'libfoo.so'
+
+        # Case 1: Dependency has slash — treat as direct path
         if "/" in dep:
-            # search SBOM entries for a library at a matching relative/absolute path
-            dep = posix_normpath(
-                dep
-            )  # normpath takes care of redundancies such as `//`->`/` and `ab/../xy`->`xy`; NOTE may change meaning of path containing symlinks
-            fname = dep.name
-            if dep.is_absolute():
-                # absolute path
-                fpaths = [str(dep)]
+            if dep_path.is_absolute():
+                fpaths = [dep_path.as_posix()]
             else:
-                # relative path
-                fpaths = []
-                # iterate through install paths for sw to get the full path to the file as it would appear in installPaths for the software entry
                 if isinstance(software.installPath, Iterable):
                     for ipath in software.installPath:
-                        ipath_posix = posix_normpath(
-                            ipath
-                        )  # NOTE symlinks in install path may be affected by normpath
-                        fpaths.append(
-                            posix_normpath(str(ipath_posix.parent.joinpath(dep))).as_posix()
-                        )  # paths to search are install path folders + relative path of dependency
+                        ipath_posix = posix_normpath(ipath)
+                        combined = ipath_posix.parent.joinpath(dep_path)
+                        fpaths.append(combined.as_posix())
+
+        # Case 2: Bare filename — use runpaths and fallback paths
         else:
-            fname = dep
-            # the paths for the dependency follow the default search path order for Linux/FreeBSD/etc
-            fpaths = [
-                p.joinpath(fname).as_posix() for p in default_search_paths
-            ]  # append fname to the end of the paths to get the full file install paths of the dependency
-
-        # Look for a software entry with a file name and install path that matches the dependency that would be loaded
-        for item in sbom.software:
-            # Check if the software entry has a name matching the dependency first as a quick check to rule out non-matches
-            if isinstance(item.fileName, Iterable) and fname not in item.fileName:
-                continue
-
-            # check if the software entry is installed to one of the paths looked at for loading the dependency
-            for fp in fpaths:
-                if isinstance(item.installPath, Iterable) and fp in item.installPath:
-                    # software matching requirements to be the loaded dependency was found
-                    dependency_uuid = item.UUID
-                    rel = Relationship(dependent_uuid, dependency_uuid, "Uses")
-                    if rel not in relationships:
-                        relationships.append(rel)
+            fpaths = [p.joinpath(fname).as_posix() for p in default_search_paths]
+
+        # Phase 1: fs_tree lookup
+        matched_uuids = set()
+        used_method = {}
+
+        for path in fpaths:
+            match = sbom.get_software_by_path(path)
+            print(f"[elf_relationship] Trying fs_tree lookup: {path} -> {match}")
+            if match:
+                matched_uuids.add(match.UUID)
+                used_method[match.UUID] = "fs_tree"
+
+        # Phase 2: Legacy installPath fallback
+        if not matched_uuids:
+            for item in sbom.software:
+                if isinstance(item.fileName, Iterable) and fname not in item.fileName:
+                    continue
+                for fp in fpaths:
+                    if isinstance(item.installPath, Iterable) and fp in item.installPath:
+                        matched_uuids.add(item.UUID)
+                        used_method[item.UUID] = "legacy_installPath"
+
+        # Phase 3: Symlink-aware heuristic
+        # If path-based and legacy matching failed, fall back to checking:
+        # - Same fileName as dependency
+        # - Located in the same directory as any search path
+        if not matched_uuids and fname:
+            for item in sbom.software:
+                if isinstance(item.fileName, Iterable) and fname in item.fileName:
+                    if isinstance(item.installPath, Iterable):
+                        for ipath in item.installPath:
+                            ip_dir = pathlib.PurePosixPath(ipath).parent
+                            for fp in fpaths:
+                                if pathlib.PurePosixPath(fp).parent == ip_dir:
+                                    matched_uuids.add(item.UUID)
+                                    used_method[item.UUID] = "symlink_heuristic"
+                                    logger.debug(f"Symlink heuristic matched: {fp} ~ {ipath}")
+
+        # Emit final relationships
+        for dependency_uuid in matched_uuids:
+            rel = Relationship(dependent_uuid, dependency_uuid, "Uses")
+            if rel not in relationships:
+                relationships.append(rel)
+                method = used_method.get(dependency_uuid, "unknown")
+                logger.debug(f"Added relationship: {rel} via {method}")
+
+    logger.debug(f"Final relationships emitted: {relationships}")
     return relationships
 
 
 def generate_search_paths(sw: Software, md) -> List[pathlib.PurePosixPath]:
-    # 1. Search using directories in DT_RPATH if present and no DT_RUNPATH exists (use of DT_RPATH is deprecated)
-    # 2. Use LD_LIBRARY_PATH environment variable; ignore if suid/sgid binary (nothing to do, we don't have this information w/o running on a live system)
-    # 3. Search using directories in DT_RUNPATH if present
-    paths = generate_runpaths(sw, md)  # will return an empty list if none
-
-    # 4. From /etc/ld.so.cache (/var/run/ld.so.hints on FreeBSD) list of compiled candidate libraries previously found in augmented library path; if binary was linked with -z nodeflib linker option, libraries in default library paths are skipped
-    # /etc/ld.so.conf can be used to add additional directories to defaults (e.g. /usr/local/lib or /opt/lib), but we don't necessarily have a way to gather this info
-    # Search in default path /lib, then /usr/lib; skip if binary was linked with -z nodeflib option
+    """
+    Combines resolved RPATH/RUNPATH paths with system default paths unless
+    DF_1_NODEFLIB is set. This reflects ELF loader behavior for dependency resolution.
+    """
+
+    # Start with RPATH or RUNPATH entries, if any
+    paths = generate_runpaths(sw, md)  # May include $ORIGIN etc., already substituted
+
+    # Check for the DF_1_NODEFLIB dynamic flag: disables default library search
     nodeflib = False
     if "elfDynamicFlags1" in md:
         if "DF_1_NODEFLIB" in md["elfDynamicFlags1"]:
             nodeflib = md["elfDynamicFlags1"]["DF_1_NODEFLIB"]
+
+    # If DF_1_NODEFLIB is not set, include default system paths
     if not nodeflib:
-        # add default search paths
-        paths.extend(
-            [pathlib.PurePosixPath(p) for p in ["/lib", "/lib64", "/usr/lib", "/usr/lib64"]]
-        )
+        paths.extend([
+            pathlib.PurePosixPath(p)
+            for p in ["/lib", "/lib64", "/usr/lib", "/usr/lib64"]
+        ])
 
-    return paths
+    # Ensure all entries are PurePosixPath objects (in case runpaths included strings)
+    return [
+        p if isinstance(p, pathlib.PurePosixPath) else pathlib.PurePosixPath(p)
+        for p in paths
+    ]
 
 
 def generate_runpaths(sw: Software, md) -> List[pathlib.PurePosixPath]:
-    # rpath and runpath are lists of strings (just in case an ELF file has several, though that is probably an invalid ELF file)
-    rp_to_use = []
-    rpath = None
-    runpath = None
-    if "elfRpath" in md and md["elfRpath"]:
-        rpath = md["elfRpath"]
-    if "elfRunpath" in md and md["elfRunpath"]:
-        runpath = md["elfRunpath"]
-
-    # 1. Search using directories in DT_RPATH if present and no DT_RUNPATH exists (use of DT_RPATH is deprecated)
-    # 3. Search using directories in DT_RUNPATH if present
-    if rpath and not runpath:
-        rp_to_use = rpath
-    elif runpath:
-        rp_to_use = runpath
-
-    # split up the paths first, then substitute DSTs
-    return [
-        sp  # append path with DSTs replaced to the list
-        for rp in rp_to_use  # iterate through all possible runpath entries
-        for p in rp.split(":")  # iterate through all components (paths) in each runpath entry
-        if p != ""  # if the path entry is not empty
-        for sp in substitute_all_dst(sw, md, p)  # substitute DSTs in the path
-    ]
+    """
+    Resolves ELF runpaths from metadata using $ORIGIN and other DST substitutions.
+
+    According to the ELF specification:
+    - If DT_RUNPATH is present, it takes precedence—even if empty.
+    - If DT_RUNPATH is missing or empty (no usable entries), fall back to DT_RPATH.
+    - Each entry may contain DST tokens ($ORIGIN, $LIB, etc.) that must be expanded.
+    """
+    runpaths = []
+
+    rpath = md.get("elfRpath") or []
+    runpath = md.get("elfRunpath") if "elfRunpath" in md else None
+
+    # According to ELF spec, presence of DT_RUNPATH disables DT_RPATH
+    if runpath is not None:
+        # RUNPATH exists: use it only if it contains usable entries
+        if any(p.strip() for p in runpath):
+            runpaths = runpath
+        else:
+            runpaths = []  # DT_RUNPATH exists but is empty: skip RPATH
+    else:
+        runpaths = rpath  # DT_RUNPATH missing entirely, fallback to RPATH
+
+    results = []
+    for rp in runpaths:
+        for p in rp.split(":"):
+            if p.strip():
+                results.extend(substitute_all_dst(sw, md, p))
+
+    print("[DEBUG] expanded runpaths:", results)
+    return [pathlib.PurePosixPath(r) for r in results]
+
+
 
 
 def replace_dst(origstr, dvar, newval) -> str:
     return origstr.replace("$" + dvar, newval).replace("${" + dvar + "}", newval)
 
 
+# def substitute_all_dst(sw: Software, md, path) -> List[pathlib.PurePosixPath]:
+#     # substitute any dynamic string tokens found; may result in multiple strings if different variants are possible
+#     # replace $ORIGIN, ${ORIGIN}, $LIB, ${LIB}, $PLATFORM, ${PLATFORM} tokens
+#     # places the dynamic linker does this expansion are:
+#     # - environment vars: LD_LIBRARY_PATH, LD_PRELOAD, and LD_AUDIT
+#     # - dynamic section tags: DT_NEEDED, DT_RPATH, DT_RUNPATH, DT_AUDIT, and DT_DEPAUDIT
+#     # - arguments to ld.so: --audit, --library-path, and --preload
+#     # - the filename arguments to dlopen and dlmopen
+#     # more details in the `Dynamic string tokens` section of https://man7.org/linux/man-pages/man8/ld.so.8.html
+#     pathlist: List[pathlib.PurePosixPath] = []
+#     # ORIGIN: replace with absolute directory containing the program or shared object (with symlinks resolved and no ../ or ./ subfolders)
+#     # for SUID/SGID binaries, after expansion the normalized path must be in a trusted directory (https://github.com/bminor/glibc/blob/0d41182/elf/dl-load.c#L356-L357, https://github.com/bminor/glibc/blob/0d41182/elf/dl-load.c#L297-L316)
+#     if (path.find("$ORIGIN") != -1) or (path.find("${ORIGIN}") != -1):
+#         if isinstance(sw.installPath, Iterable):
+#             for ipath in sw.installPath:
+#                 origin = pathlib.PurePosixPath(ipath).parent.as_posix()
+#                 pathlist.append(pathlib.PurePosixPath(replace_dst(path, "ORIGIN", origin)))
+
+#     # LIB: expands to `lib` or `lib64` depending on arch (x86-64 to lib64, x86-32 to lib)
+#     if (path.find("$LIB") != -1) or (path.find("${LIB}") != -1):
+#         if not pathlist:
+#             # nothing in the original pathlist, use the original path passed in
+#             pathlist.append(pathlib.PurePosixPath(replace_dst(path, "LIB", "lib")))
+#             pathlist.append(pathlib.PurePosixPath(replace_dst(path, "LIB", "lib64")))
+#         else:
+#             # perform substitutions with every current entry in pathlist
+#             pathlist = [
+#                 newp
+#                 for p in pathlist
+#                 for newp in (
+#                     pathlib.PurePosixPath(replace_dst(p, "LIB", "lib")),
+#                     pathlib.PurePosixPath(replace_dst(p, "LIB", "lib64")),
+#                 )
+#             ]
+
+#     # PLATFORM: expands to string corresponding to CPU type of the host system (e.g. "x86_64")
+#     # some archs the string comes from AT_PLATFORM value in auxiliary vector (getauxval)
+#     if (path.find("$PLATFORM") != -1) or (path.find("${PLATFORM}") != -1):
+#         # NOTE consider using what is known about the target CPU of the ELF binary, and get all possible PLATFORM values based on that from glibc/muslc source code?
+#         #      this would take some significant amount of searching (inconsistent in how different platforms set the value), and could result in a large increase in
+#         #      the number of search paths for a feature that is rarely used (similar to hwcaps subfolder searching)
+#         # For now, discard paths given that no valid substitution was found
+#         return []
+
+#     # normalize paths after expanding tokens to avoid portions of the path involving  ../, ./, and // occurrences
+#     pathlist = [posix_normpath(p.as_posix()) for p in pathlist]
+#     return pathlist
+
 def substitute_all_dst(sw: Software, md, path) -> List[pathlib.PurePosixPath]:
-    # substitute any dynamic string tokens found; may result in multiple strings if different variants are possible
-    # replace $ORIGIN, ${ORIGIN}, $LIB, ${LIB}, $PLATFORM, ${PLATFORM} tokens
-    # places the dynamic linker does this expansion are:
-    # - environment vars: LD_LIBRARY_PATH, LD_PRELOAD, and LD_AUDIT
-    # - dynamic section tags: DT_NEEDED, DT_RPATH, DT_RUNPATH, DT_AUDIT, and DT_DEPAUDIT
-    # - arguments to ld.so: --audit, --library-path, and --preload
-    # - the filename arguments to dlopen and dlmopen
-    # more details in the `Dynamic string tokens` section of https://man7.org/linux/man-pages/man8/ld.so.8.html
+    """
+    Expands dynamic string tokens (DSTs) in ELF search paths like $ORIGIN, $LIB, $PLATFORM.
+    If no DSTs are present, returns the original path unchanged.
+
+    Parameters:
+        sw (Software): The software object (used for $ORIGIN resolution).
+        md (dict): ELF metadata.
+        path (str): The raw path string to process.
+
+    Returns:
+        List[pathlib.PurePosixPath]: All normalized, substituted search paths.
+    """
     pathlist: List[pathlib.PurePosixPath] = []
-    # ORIGIN: replace with absolute directory containing the program or shared object (with symlinks resolved and no ../ or ./ subfolders)
-    # for SUID/SGID binaries, after expansion the normalized path must be in a trusted directory (https://github.com/bminor/glibc/blob/0d41182/elf/dl-load.c#L356-L357, https://github.com/bminor/glibc/blob/0d41182/elf/dl-load.c#L297-L316)
-    if (path.find("$ORIGIN") != -1) or (path.find("${ORIGIN}") != -1):
-        if isinstance(sw.installPath, Iterable):
-            for ipath in sw.installPath:
-                origin = pathlib.PurePosixPath(ipath).parent.as_posix()
-                pathlist.append(pathlib.PurePosixPath(replace_dst(path, "ORIGIN", origin)))
-
-    # LIB: expands to `lib` or `lib64` depending on arch (x86-64 to lib64, x86-32 to lib)
-    if (path.find("$LIB") != -1) or (path.find("${LIB}") != -1):
+
+    has_origin = "$ORIGIN" in path or "${ORIGIN}" in path
+    has_lib = "$LIB" in path or "${LIB}" in path
+    has_platform = "$PLATFORM" in path or "${PLATFORM}" in path
+
+    # ----------------------
+    # ORIGIN token expansion
+    # ----------------------
+    if has_origin and isinstance(sw.installPath, Iterable):
+        for ipath in sw.installPath:
+            origin = pathlib.PurePosixPath(ipath).parent.as_posix()
+            pathlist.append(pathlib.PurePosixPath(replace_dst(path, "ORIGIN", origin)))
+
+    # ------------------
+    # LIB token expansion
+    # ------------------
+    if has_lib:
         if not pathlist:
-            # nothing in the original pathlist, use the original path passed in
-            pathlist.append(pathlib.PurePosixPath(replace_dst(path, "LIB", "lib")))
-            pathlist.append(pathlib.PurePosixPath(replace_dst(path, "LIB", "lib64")))
-        else:
-            # perform substitutions with every current entry in pathlist
-            pathlist = [
-                newp
-                for p in pathlist
-                for newp in (
-                    pathlib.PurePosixPath(replace_dst(p, "LIB", "lib")),
-                    pathlib.PurePosixPath(replace_dst(p, "LIB", "lib64")),
-                )
-            ]
-
-    # PLATFORM: expands to string corresponding to CPU type of the host system (e.g. "x86_64")
-    # some archs the string comes from AT_PLATFORM value in auxiliary vector (getauxval)
-    if (path.find("$PLATFORM") != -1) or (path.find("${PLATFORM}") != -1):
-        # NOTE consider using what is known about the target CPU of the ELF binary, and get all possible PLATFORM values based on that from glibc/muslc source code?
-        #      this would take some significant amount of searching (inconsistent in how different platforms set the value), and could result in a large increase in
-        #      the number of search paths for a feature that is rarely used (similar to hwcaps subfolder searching)
-        # For now, discard paths given that no valid substitution was found
+            # No ORIGIN was expanded; use original path
+            pathlist.append(pathlib.PurePosixPath(path))
+        pathlist = [
+            newp
+            for p in pathlist
+            for newp in (
+                pathlib.PurePosixPath(replace_dst(p, "LIB", "lib")),
+                pathlib.PurePosixPath(replace_dst(p, "LIB", "lib64")),
+            )
+        ]
+
+    # ----------------------
+    # PLATFORM not supported
+    # ----------------------
+    if has_platform:
+        # No way to resolve this reliably (varies by CPU/platform).
+        # Returning empty disables unresolved PLATFORM paths.
         return []
 
-    # normalize paths after expanding tokens to avoid portions of the path involving  ../, ./, and // occurrences
-    pathlist = [posix_normpath(p.as_posix()) for p in pathlist]
-    return pathlist
+    # -------------------------
+    # No DSTs? Use original path
+    # -------------------------
+    if not (has_origin or has_lib or has_platform) and not pathlist:
+        pathlist.append(pathlib.PurePosixPath(path))
+
+    # -------------------------
+    # Normalize all paths
+    # -------------------------
+    return [posix_normpath(p.as_posix()) for p in pathlist]
diff --git a/surfactant/sbomtypes/_sbom.py b/surfactant/sbomtypes/_sbom.py
index b96e465..672663a 100644
--- a/surfactant/sbomtypes/_sbom.py
+++ b/surfactant/sbomtypes/_sbom.py
@@ -7,11 +7,12 @@ from __future__ import annotations
 import json
 import uuid as uuid_module
 from dataclasses import asdict, dataclass, field, fields
-from typing import Dict, List, Optional, Set
+from typing import Dict, List, Optional, Set, Tuple
 
 import networkx as nx
 from dataclasses_json import config, dataclass_json
 from loguru import logger
+import pathlib
 
 from ._analysisdata import AnalysisData
 from ._file import File
@@ -56,6 +57,11 @@ class SBOM:
     observations: List[Observation] = field(default_factory=list)
     starRelationships: Set[StarRelationship] = field(default_factory=set)
     software_lookup_by_sha256: Dict = field(default_factory=dict)
+    fs_tree: nx.DiGraph = field(
+        init=False,
+        repr=False,
+        metadata=config(exclude=lambda _: True),
+    )
     graph: nx.MultiDiGraph = field(
         init=False,
         repr=False,
@@ -127,10 +133,43 @@ class SBOM:
             k: v for k, v in self.__dataclass_fields__.items() if k not in INTERNAL_FIELDS
         }
 
-        # Build the NetworkX graph from systems/software and loaded relationships
-        self.build_graph()
+        # Build the Relationship graph from systems/software and loaded relationships
+        self.build_rel_graph()
+
+        # Initialize fs_tree
+        self.fs_tree = nx.DiGraph()
+
+        # Populate from installPaths (if present)
+        for sw in self.software:
+            self._add_software_to_fs_tree(sw)
+
+
+    def _add_software_to_fs_tree(self, sw):
+        if not sw.installPath:
+            return
+
+        for path in sw.installPath:
+            norm_path = pathlib.PurePosixPath(path).as_posix()
+            parts = pathlib.PurePosixPath(norm_path).parts
+
+            for i in range(1, len(parts)):
+                parent = pathlib.PurePosixPath(*parts[:i]).as_posix()
+                child = pathlib.PurePosixPath(*parts[:i+1]).as_posix()
+                self.fs_tree.add_edge(parent, child)
+
+            self.fs_tree.nodes[norm_path]["software_uuid"] = sw.UUID
+
+
+    def get_software_by_path(self, path: str):
+        """
+        Retrieve a Software entry by exact install path, using the fs_tree.
+        """
+        node = self.fs_tree.nodes.get(path)
+        if node and "software_uuid" in node:
+            return self._find_software_entry(uuid=node["software_uuid"])
+        return None
 
-    def build_graph(self) -> None:
+    def build_rel_graph(self) -> None:
         """Rebuild the directed graph from systems, software, and any loaded relationships."""
         self.graph = nx.MultiDiGraph()
         for sys in self.systems:
@@ -216,51 +255,162 @@ class SBOM:
         if not self.graph.has_node(sw.UUID):
             self.graph.add_node(sw.UUID, type="Software")
 
+        self._add_software_to_fs_tree(sw)
+
+
+    def _record_symlink(
+        self,
+        link_path: str,
+        target_path: str,
+        *,
+        subtype: Optional[str] = None
+    ) -> None:
+        """
+        Record a filesystem symlink in both the SBOM’s relationship graph and its fs_tree.
+
+        This does three things:
+        1. Normalizes both paths to POSIX style.
+        2. Ensures both link and target are present as nodes in:
+            • self.graph       (networkx.MultiDiGraph of software relationships)
+            • self.fs_tree     (networkx.DiGraph of file system paths)
+        3. Adds a directed edge link → target in both graphs with:
+            - type="symlink"
+            - subtype=<optional qualifier, e.g. "file" or "directory">
+
+        By capturing symlink edges in fs_tree you enable sbom.get_software_by_path()
+        to traverse through symlinks when resolving ELF dependencies.
+
+        Args:
+            link_path:   Path of the symlink itself (e.g. "/opt/app/lib/foo.so").
+            target_path: The resolved target path (e.g. "/usr/lib/foo.so").
+            subtype:     Optional kind of symlink, e.g. "file" or "directory".
+        """
+        # Normalize inputs to canonical POSIX strings
+        link_node = pathlib.PurePosixPath(link_path).as_posix()
+        target_node = pathlib.PurePosixPath(target_path).as_posix()
+
+        # -------------------------------------------------------------------------
+        # Ensure nodes exist in the SBOM’s main graph, then record the symlink
+        # -------------------------------------------------------------------------
+        for node in (link_node, target_node):
+            if not self.graph.has_node(node):
+                self.graph.add_node(node)
+                logger.debug(f"[graph] Added node for symlink tracking: {node}")
+
+        # Only add one 'symlink' edge per exact (link, target, key)
+        if not self.graph.has_edge(link_node, target_node, key="symlink"):
+            self.graph.add_edge(link_node, target_node, key="symlink")
+            logger.debug(f"[graph] Recorded symlink edge: {link_node} → {target_node}")
+
+        # -------------------------------------------------------------------------
+        # Mirror into fs_tree so dependency resolution can follow symlinks there
+        # -------------------------------------------------------------------------
+        for node in (link_node, target_node):
+            if not self.fs_tree.has_node(node):
+                self.fs_tree.add_node(node)
+                logger.debug(f"[fs_tree] Added symlink node: {node}")
+
+        # Check existing fs_tree edges from link → target
+        existing = self.fs_tree.get_edge_data(link_node, target_node, default={})
+        seen = any(
+            attrs.get("type") == "symlink" and attrs.get("subtype") == subtype
+            for attrs in existing.values()
+        )
+
+        if not seen:
+            # record with both a fixed type and optional subtype
+            self.fs_tree.add_edge(
+                link_node,
+                target_node,
+                type="symlink",
+                subtype=subtype
+            )
+            msg = f"[fs_tree] Recorded symlink edge: {link_node} → {target_node}"
+            if subtype:
+                msg += f" [subtype={subtype}]"
+            logger.debug(msg)
+        else:
+            logger.debug(f"[fs_tree] Symlink edge already exists: {link_node} → {target_node}")
+
+
     def add_software_entries(
         self, entries: Optional[List[Software]], parent_entry: Optional[Software] = None
     ):
-        """Add software entries, merging duplicates and preserving all relationship edges.
+        """
+        Add software entries to the SBOM graph, merging duplicates, preserving existing edges,
+        attaching "Contains" relationships to an optional parent, and recording ANY
+        file- or directory-level symlinks under each installPath.
 
         Args:
-            entries (Optional[List[Software]]): A list of Software entries to add to the SBOM.
-            parent_entry (Optional[Software]): An optional parent software entry to add "Contains" relationships to.
+            entries:        list of Software instances to add.
+            parent_entry:   if provided, attach a "Contains" edge from this parent to each entry.
         """
         if not entries:
             return
+        
         # if a software entry already exists with a matching file hash, augment the info in the existing entry
-        for e in entries:
-            existing = self.find_software(e.sha256)
-            if existing and Software.check_for_hash_collision(existing, e):
-                logger.warning(f"Hash collision between {existing.name} and {e.name}")
-
-            if not existing:
-                # new software → add node
-                self.add_software(e)
-                entry_uuid = e.UUID
-            else:
-                # duplicate → merge and redirect edges
-                kept_uuid, old_uuid = existing.merge(e)
-
-                # redirect *incoming* edges to the kept node
+        for sw  in entries:
+            #  Merge duplicates by sha256 (or insert if new)
+            existing = self.find_software(sw.sha256)
+            if existing and Software.check_for_hash_collision(existing, sw):
+                logger.warning(f"Hash collision between {existing.name} and {sw.name}")
+
+            if existing:
+                # Merge into existing node
+                # Duplicate → merge data & edges, drop the old UUID
+                kept_uuid, old_uuid = existing.merge(sw)
+                logger.debug(f"Merged {sw.UUID} into {kept_uuid}, removing {old_uuid}")
+
+                # Redirect *incoming* edges to the kept node
                 for src, _, key, attrs in list(self.graph.in_edges(old_uuid, keys=True, data=True)):
                     self.graph.add_edge(src, kept_uuid, key=key, **attrs)
 
-                # redirect *outgoing* edges from the old node
+                # Redirect *outgoing* edges from the old node
                 for _, dst, key, attrs in list(
                     self.graph.out_edges(old_uuid, keys=True, data=True)
                 ):
                     self.graph.add_edge(kept_uuid, dst, key=key, **attrs)
 
-                # remove the old UUID entirely
+                # Remove the old UUID entirely
                 if self.graph.has_node(old_uuid):
                     self.graph.remove_node(old_uuid)
-                entry_uuid = kept_uuid
+                node_uuid = kept_uuid
+
+            else:                
+                # New software → add node
+                self.add_software(sw)
+                node_uuid = sw.UUID
+                logger.debug(f"Added new software node {node_uuid}")
+
 
-            # if a parent/package container was provided, attach a "Contains" edge
+            # Attach a Contains edge from parent, if any
             if parent_entry:
                 parent_uuid = parent_entry.UUID
-                if not self.graph.has_edge(parent_uuid, entry_uuid, key="Contains"):
-                    self.graph.add_edge(parent_uuid, entry_uuid, key="Contains")
+                if not self.graph.has_edge(parent_uuid, node_uuid, key="Contains"):
+                    self.graph.add_edge(parent_uuid, node_uuid, key="Contains")
+                    logger.debug(f"Attached Contains edge: {parent_uuid} → {node_uuid}")
+
+
+            # Symlink capture under each installPath ---
+            for raw in sw.installPath or []:
+                p = pathlib.Path(raw)
+
+                # If the installPath itself is a symlink (file or dir)
+                if p.is_symlink():
+                    real = p.resolve()
+                    subtype = "file" if not p.is_dir() else "directory"
+                    logger.debug(f"Found installPath symlink: {p} → {real} (subtype={subtype})")
+                    # Call the helper to record this symlink in fs_tree
+                    self._record_symlink(str(p), str(real), subtype=subtype)
+
+                # If it's a directory, scan immediate children for symlinks
+                if p.is_dir():
+                    for child in p.iterdir():
+                        if child.is_symlink():
+                            real = child.resolve()
+                            subtype = "file" if not child.is_dir() else "directory"
+                            logger.debug(f"Found child symlink: {child} → {real} (subtype={subtype})")
+                            self._record_symlink(str(child), str(real), subtype=subtype)
 
     # pylint: disable=too-many-arguments
     def create_software(
@@ -598,6 +748,7 @@ class SBOM:
 
         # Remove fields we never want in JSON
         data.pop("graph", None)
+        data.pop("fs_tree", None) # Prevent DiGraph from being serialized
         data.pop("_loaded_relationships", None)
 
         # Turn any sets into lists for JSON
diff --git a/tests/relationships/test_elf_relationship.py b/tests/relationships/test_elf_relationship.py
new file mode 100644
index 0000000..a341b62
--- /dev/null
+++ b/tests/relationships/test_elf_relationship.py
@@ -0,0 +1,160 @@
+import pathlib
+import pytest
+from surfactant.sbomtypes import SBOM, Software, Relationship
+from surfactant.relationships import elf_relationship
+from surfactant.relationships.elf_relationship import establish_relationships
+
+@pytest.fixture
+def example_sbom():
+    sbom = SBOM()
+
+    sw1 = Software(UUID="uuid-1", fileName=["libfoo.so.1"], installPath=["/usr/lib/libfoo.so.1"])
+    sw2 = Software(UUID="uuid-2", fileName=["libbar.so"], installPath=["/opt/myapp/lib/libbar.so"])
+
+    sw3a = Software(UUID="uuid-3a", installPath=["/opt/myapp/bin/myapp"], metadata=[{"elfDependencies": ["/usr/lib/libfoo.so.1"]}])
+    sw3b = Software(UUID="uuid-3b", installPath=["/opt/myapp/bin/myapp"], metadata=[{"elfDependencies": ["libbar.so"], "elfRunpath": ["$ORIGIN/../lib"]}])
+    sw4 = Software(UUID="uuid-4", fileName=["libxyz.so"], installPath=["/lib/libxyz.so"], metadata=[{"elfDependencies": ["libxyz.so"]}])
+    sw5 = Software(UUID="uuid-5", fileName=["libdep.so"], installPath=["/app/lib/libdep.so"])
+    sw6 = Software(UUID="uuid-6", installPath=["/app/bin/mybin"], metadata=[{"elfDependencies": ["libdep.so"], "elfRunpath": ["$ORIGIN/../lib"]}])
+    sw7 = Software(UUID="uuid-7", installPath=["/legacy/bin/legacyapp"], metadata=[{"elfDependencies": ["libbar.so"], "elfRpath": ["/opt/myapp/lib"]}])
+    sw8 = Software(UUID="uuid-8", fileName=["libalias.so"], installPath=["/opt/alt/lib/libreal.so"])
+    sw9 = Software(UUID="uuid-9", installPath=["/opt/alt/bin/app"], metadata=[{"elfDependencies": ["libalias.so"], "elfRunpath": ["/opt/alt/lib"]}])
+
+    for sw in [sw1, sw2, sw3a, sw3b, sw4, sw5, sw6, sw7, sw8, sw9]:
+        sbom.add_software(sw)
+
+    return sbom, {
+        "absolute": (sw3a, "uuid-1"),
+        "relative": (sw3b, "uuid-2"),
+        "system": (sw4, "uuid-4"),
+        "origin": (sw6, "uuid-5"),
+        "rpath": (sw7, "uuid-2"),
+        "symlink": (sw9, "uuid-8")
+    }
+
+@pytest.mark.parametrize("label", ["absolute", "relative", "system", "origin", "rpath", "symlink"])
+def test_elf_relationship_cases(example_sbom, label):
+    print(f"==== RUNNING: {label} ====")
+    sbom, case_map = example_sbom
+    sw, expected_uuid = case_map[label]
+    metadata = sw.metadata[0] if sw.metadata else {}
+    print("Dependency paths:", metadata.get("elfDependencies", []))
+    print("fs_tree nodes:", list(sbom.fs_tree.nodes))
+    for dep in metadata.get("elfDependencies", []):
+        norm = pathlib.PurePosixPath(dep).as_posix()
+        print(f"Trying lookup: {norm} ->", sbom.get_software_by_path(norm))
+    result = elf_relationship.establish_relationships(sbom, sw, metadata)
+    assert result is not None, f"{label} case failed: no result"
+    assert len(result) == 1, f"{label} case failed: expected 1 relationship"
+    assert result[0] == Relationship(sw.UUID, expected_uuid, "Uses"), f"{label} case mismatch: {result[0]} != {expected_uuid}"
+
+
+
+@pytest.fixture
+def symlink_heuristic_sbom():
+    """
+    Constructs a test SBOM scenario where the only valid match is via the symlink heuristic.
+
+    - The binary depends on 'libalias.so'
+    - The SBOM does not include a direct path or fs_tree match for 'libalias.so'
+    - The candidate dependency's fileName matches 'libalias.so'
+    - The candidate dependency's installPath parent directory matches search path
+    """
+    # Binary depending on 'libalias.so' with a runpath that includes /opt/app/lib
+    binary = Software(
+        UUID="bin-uuid",
+        fileName=["myapp"],
+        installPath=["/opt/app/bin/myapp"],
+        metadata=[{
+            "elfDependencies": ["libalias.so"],
+            "elfRunpath": ["/opt/app/lib"]
+        }]
+    )
+
+    # Candidate dependency: install path and fileName line up for heuristic
+    dependency = Software(
+        UUID="lib-uuid",
+        fileName=["libalias.so"],
+        installPath=["/opt/app/lib/libalias.so"]
+    )
+
+    sbom = SBOM()
+    sbom.add_software(binary)
+    sbom.add_software(dependency)
+
+    return sbom, binary
+
+
+def test_symlink_heuristic_match(symlink_heuristic_sbom):
+    sbom, binary = symlink_heuristic_sbom
+    metadata = binary.metadata[0]
+
+    results = establish_relationships(sbom, binary, metadata)
+
+    assert results is not None, "Expected relationship from symlink heuristic"
+    assert len(results) == 1
+    assert results[0] == Relationship("bin-uuid", "lib-uuid", "Uses")
+
+
+def test_no_match_edge_case():
+    """
+    Test case: No matching dependency by any means (fs_tree, legacy, or heuristic).
+    Expect no relationships.
+    """
+    binary = Software(
+        UUID="bin-uuid",
+        fileName=["mybin"],
+        installPath=["/some/bin/mybin"],
+        metadata=[{
+            "elfDependencies": ["libnotfound.so"],
+            "elfRunpath": ["/some/lib"]
+        }]
+    )
+
+    unrelated = Software(
+        UUID="unrelated-uuid",
+        fileName=["libsomethingelse.so"],
+        installPath=["/unrelated/path/libsomethingelse.so"]
+    )
+
+    sbom = SBOM(systems=[], hardware=[], software=[binary, unrelated])
+    sbom.fs_tree.add_node("/unrelated/path/libsomethingelse.so", software=unrelated)
+
+
+    metadata = binary.metadata[0]
+    results = establish_relationships(sbom, binary, metadata)
+
+    assert results is not None
+    assert len(results) == 0, "Expected no relationships for unmatched dependency"
+
+
+def test_symlink_heuristic_guard():
+    """
+    Tests that the symlink heuristic does not falsely match entries where
+    fileName matches but installPath is in a different directory.
+    """
+    binary = Software(
+        UUID="bin-uuid",
+        fileName=["myapp"],
+        installPath=["/opt/app/bin/myapp"],
+        metadata=[{
+            "elfDependencies": ["libalias.so"],
+            "elfRunpath": ["/opt/app/lib"]
+        }]
+    )
+
+    # Same file name, but located in a different directory -> should NOT match
+    candidate = Software(
+        UUID="falsematch-uuid",
+        fileName=["libalias.so"],
+        installPath=["/different/dir/libalias.so"]
+    )
+
+    sbom = SBOM(systems=[], hardware=[], software=[binary, candidate])
+    sbom.fs_tree.add_node("/different/dir/libalias.so", software=candidate)
+
+    metadata = binary.metadata[0]
+    results = establish_relationships(sbom, binary, metadata)
+
+    assert results is not None
+    assert all(rel.yUUID != "falsematch-uuid" for rel in results), "Heuristic should not have matched"
diff --git a/tests/sbomtypes/test_fs_tree.py b/tests/sbomtypes/test_fs_tree.py
new file mode 100644
index 0000000..4408e62
--- /dev/null
+++ b/tests/sbomtypes/test_fs_tree.py
@@ -0,0 +1,43 @@
+import networkx as nx
+import pytest
+from surfactant.sbomtypes import SBOM, Software
+@pytest.fixture
+def software_entries():
+    return [
+        Software(UUID="uuid-1", installPath=["/usr/bin/ls"]),
+        Software(UUID="uuid-2", installPath=["/usr/lib/libc.so"]),
+        Software(UUID="uuid-3", installPath=["/opt/tools/bin/run"]),
+    ]
+
+def test_fs_tree_population(software_entries):
+    sbom = SBOM()
+    for sw in software_entries:
+        sbom.add_software(sw)  # This should trigger _add_software_to_fs_tree()
+    fs = sbom.fs_tree
+    # Check that expected nodes exist
+    assert fs.has_node("/usr")
+    assert fs.has_node("/usr/bin")
+    assert fs.has_node("/usr/bin/ls")
+    assert fs.has_node("/usr/lib/libc.so")
+    assert fs.has_node("/opt/tools/bin/run")
+    # Check that edges reflect directory hierarchy
+    assert fs.has_edge("/usr", "/usr/bin")
+    assert fs.has_edge("/usr/bin", "/usr/bin/ls")
+    assert fs.has_edge("/usr/lib", "/usr/lib/libc.so")
+    assert fs.has_edge("/opt", "/opt/tools")
+    assert fs.has_edge("/opt/tools/bin", "/opt/tools/bin/run")
+    # Check software UUID tagging
+    assert fs.nodes["/usr/bin/ls"]["software_uuid"] == "uuid-1"
+    assert fs.nodes["/usr/lib/libc.so"]["software_uuid"] == "uuid-2"
+    assert fs.nodes["/opt/tools/bin/run"]["software_uuid"] == "uuid-3"
+
+def test_get_software_by_path(software_entries):
+    sbom = SBOM()
+    for sw in software_entries:
+        sbom.add_software(sw)
+    sw1 = sbom.get_software_by_path("/usr/bin/ls")
+    sw2 = sbom.get_software_by_path("/opt/tools/bin/run")
+    sw_invalid = sbom.get_software_by_path("/nonexistent")
+    assert sw1.UUID == "uuid-1"
+    assert sw2.UUID == "uuid-3"
+    assert sw_invalid is None
\ No newline at end of file
